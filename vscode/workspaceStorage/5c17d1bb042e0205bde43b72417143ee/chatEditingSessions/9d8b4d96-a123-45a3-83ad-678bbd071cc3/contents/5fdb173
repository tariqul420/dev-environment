"use client";"use client";



import { AlertCircleIcon, ImageIcon, UploadIcon, XIcon, GripVerticalIcon } from "lucide-react";import {

import Image from "next/image";  AlertCircleIcon,

import { useCallback, useEffect, useMemo, useRef, useState } from "react";  GripVerticalIcon,

import { useFormContext } from "react-hook-form";  ImageIcon,

  UploadIcon,

import { Button } from "@/components/ui/button";  XIcon,

import {} from "lucide-react";

  FormControl,import Image from "next/image";

  FormField,import { useCallback, useEffect, useMemo, useRef, useState } from "react";

  FormItem,import { useFormContext } from "react-hook-form";

  FormLabel,

  FormMessage,import { Button } from "@/components/ui/button";

} from "@/components/ui/form";import {

import { useFileUpload } from "@/lib/hooks/use-file-upload";  FormControl,

import { cn } from "@/lib/utils";                            )}

                            

type Props = {                            {multiple && !isBusy && (

  name: string;                              <div className="absolute top-1 left-1 z-20 p-1 rounded-full bg-black/20 backdrop-blur-sm pointer-events-none">

  label: string;                                <GripVerticalIcon className="size-3 text-white" />

  multiple?: boolean;                              </div>

  className?: string;                            )}

  viewClass?: string;                            

};                            {src ? (ld,

  FormItem,

type InitialFileMeta = {  FormLabel,

  name: string;  FormMessage,

  size: number;} from "@/components/ui/form";

  type: string;import { useFileUpload } from "@/lib/hooks/use-file-upload";

  url: string;import { cn } from "@/lib/utils";

  id: string;

};type Props = {

  name: string;

/** Unsigned Cloudinary upload via REST */  label: string;

async function uploadToCloudinary(file: File): Promise<string> {  multiple?: boolean;

  const cloudName = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME;  className?: string;

  const preset = process.env.NEXT_PUBLIC_CLOUDINARY_PRESET;  viewClass?: string;

};

  if (!cloudName || !preset) {

    throw new Error(type InitialFileMeta = {

      "Missing Cloudinary config. Set NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME and NEXT_PUBLIC_CLOUDINARY_PRESET.",  name: string;

    );  size: number;

  }  type: string;

  url: string;

  const endpoint = `https://api.cloudinary.com/v1_1/${cloudName}/upload`;  id: string;

  const body = new FormData();};

  body.append("file", file);

  body.append("upload_preset", preset);/** Unsigned Cloudinary upload via REST */

async function uploadToCloudinary(file: File): Promise<string> {

  const res = await fetch(endpoint, { method: "POST", body });  const cloudName = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME;

  if (!res.ok)  const preset = process.env.NEXT_PUBLIC_CLOUDINARY_PRESET;

    throw new Error((await res.text()) || "Cloudinary upload failed");

  const json = await res.json();  if (!cloudName || !preset) {

  return json.secure_url as string;    throw new Error(

}      "Missing Cloudinary config. Set NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME and NEXT_PUBLIC_CLOUDINARY_PRESET.",

    );

export default function ImageUploaderField({  }

  name,

  label,  const endpoint = `https://api.cloudinary.com/v1_1/${cloudName}/upload`;

  multiple = false,  const body = new FormData();

  className,  body.append("file", file);

  viewClass,  body.append("upload_preset", preset);

}: Props) {

  const { control, setValue, getValues } = useFormContext();  const res = await fetch(endpoint, { method: "POST", body });

  if (!res.ok)

  // --- RHF helpers ---    throw new Error((await res.text()) || "Cloudinary upload failed");

  const getList = useCallback((): string[] => {  const json = await res.json();

    const v = getValues(name);  return json.secure_url as string;

    if (Array.isArray(v)) return (v as string[]).filter(Boolean);}

    if (typeof v === "string" && v.trim()) return [v.trim()];

    return [];export default function ImageUploaderField({

  }, [getValues, name]);  name,

  label,

  const setList = useCallback(  multiple = false,

    (urls: string[]) => {  className,

      if (multiple) {  viewClass,

        setValue(name, urls, { shouldDirty: true, shouldValidate: true });}: Props) {

      } else {  const { control, setValue, getValues } = useFormContext();

        setValue(name, urls[0] ?? "", {

          shouldDirty: true,  // --- RHF helpers ---

          shouldValidate: true,  const getList = useCallback((): string[] => {

        });    const v = getValues(name);

      }    if (Array.isArray(v)) return (v as string[]).filter(Boolean);

    },    if (typeof v === "string" && v.trim()) return [v.trim()];

    [multiple, name, setValue],    return [];

  );  }, [getValues, name]);



  // Build initial files from RHF (string | string[])  const setList = useCallback(

  const initialFiles: InitialFileMeta[] = useMemo(() => {    (urls: string[]) => {

    const urls = getList();      if (multiple) {

    return urls.map((url, i) => ({        setValue(name, urls, { shouldDirty: true, shouldValidate: true });

      name: `image-${i + 1}.jpg`,      } else {

      size: 0,        setValue(name, urls[0] ?? "", {

      type: "image/jpeg",          shouldDirty: true,

      url,          shouldValidate: true,

      id: `init-${i}-${url}`,        });

    }));      }

  }, [getList]);    },

    [multiple, name, setValue],

  const maxSizeMB = 5;  );

  const maxSize = maxSizeMB * 1024 * 1024;

  const maxFiles = multiple ? 10 : 1;  // Build initial files from RHF (string | string[])

  const initialFiles: InitialFileMeta[] = useMemo(() => {

  const [    const urls = getList();

    { files, isDragging, errors },    return urls.map((url, i) => ({

    {      name: `image-${i + 1}.jpg`,

      handleDragEnter,      size: 0,

      handleDragLeave,      type: "image/jpeg",

      handleDragOver,      url,

      handleDrop,      id: `init-${i}-${url}`,

      openFileDialog,    }));

      removeFile,  }, [getList]);

      getInputProps,

      clearErrors,  const maxSizeMB = 5;

    },  const maxSize = maxSizeMB * 1024 * 1024;

  ] = useFileUpload({  const maxFiles = multiple ? 10 : 1;

    accept: "image/svg+xml,image/png,image/jpeg,image/jpg,image/gif",

    maxSize,  const [

    multiple,    { files, isDragging, errors },

    maxFiles,    {

    initialFiles,      handleDragEnter,

  });      handleDragLeave,

      handleDragOver,

  const idToUrl = useRef<Record<string, string>>(      handleDrop,

    Object.fromEntries(initialFiles.map((f) => [f.id, f.url])),      openFileDialog,

  );      removeFile,

      getInputProps,

  const [busyIds, setBusyIds] = useState<Record<string, boolean>>({});      clearErrors,

  const [topError, setTopError] = useState<string | null>(null);    },

    ] = useFileUpload({

  // Drag and drop reordering state    accept: "image/svg+xml,image/png,image/jpeg,image/jpg,image/gif",

  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);    maxSize,

  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);    multiple,

    maxFiles,

  useEffect(() => {    initialFiles,

    const current = getList();  });

    if (current.length === 0 && initialFiles.length > 0) {

      setList(initialFiles.map((f) => f.url));  const idToUrl = useRef<Record<string, string>>(

    }    Object.fromEntries(initialFiles.map((f) => [f.id, f.url])),

  }, [getList, initialFiles.length, initialFiles.map, setList]);  );



  useEffect(() => {  const [busyIds, setBusyIds] = useState<Record<string, boolean>>({});

    let cancelled = false;  const [topError, setTopError] = useState<string | null>(null);

  

    const sync = async () => {  // Drag and drop reordering state

      setTopError(null);  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);

      clearErrors?.();  const [dragOverIndex, setDragOverIndex] = useState<number | null>(null);



      for (const f of files) {  useEffect(() => {

        const id = f.id as string;    const current = getList();

    if (current.length === 0 && initialFiles.length > 0) {

        if (idToUrl.current[id]) continue;      setList(initialFiles.map((f) => f.url));

    }

        if (f.file && f.file instanceof File) {  }, [getList, initialFiles.length, initialFiles.map, setList]);

          try {

            setBusyIds((p) => ({ ...p, [id]: true }));  useEffect(() => {

            const secureUrl = await uploadToCloudinary(f.file);    let cancelled = false;

            if (cancelled) return;

    const sync = async () => {

            idToUrl.current[id] = secureUrl;      setTopError(null);

      clearErrors?.();

            if (multiple) {

              setList([...getList(), secureUrl]);      for (const f of files) {

            } else {        const id = f.id as string;

              setList([secureUrl]);

            }        if (idToUrl.current[id]) continue;

          } catch (e: unknown) {

            if (!cancelled) {        if (f.file && f.file instanceof File) {

              const errorMessage =          try {

                typeof e === "object" && e !== null && "message" in e            setBusyIds((p) => ({ ...p, [id]: true }));

                  ? (e as { message?: string }).message            const secureUrl = await uploadToCloudinary(f.file);

                  : undefined;            if (cancelled) return;

              setTopError(errorMessage ?? "Failed to upload image.");

              removeFile(id);            idToUrl.current[id] = secureUrl;

              delete idToUrl.current[id];

            }            if (multiple) {

          } finally {              setList([...getList(), secureUrl]);

            if (!cancelled) {            } else {

              setBusyIds((p) => {              setList([secureUrl]);

                const { [id]: _omit, ...rest } = p;            }

                return rest;          } catch (e: unknown) {

              });            if (!cancelled) {

            }              const errorMessage =

          }                typeof e === "object" && e !== null && "message" in e

        }                  ? (e as { message?: string }).message

      }                  : undefined;

    };              setTopError(errorMessage ?? "Failed to upload image.");

              removeFile(id);

    sync();              delete idToUrl.current[id];

    return () => {            }

      cancelled = true;          } finally {

    };            if (!cancelled) {

  }, [files, multiple, clearErrors, getList, removeFile, setList]);              setBusyIds((p) => {

                const { [id]: _omit, ...rest } = p;

  const handleRemove = useCallback(                return rest;

    (id: string) => {              });

      const url = idToUrl.current[id];            }

      if (url) {          }

        setList(getList().filter((u) => u !== url));        }

        delete idToUrl.current[id];      }

      }    };

      removeFile(id);

    },    sync();

    [getList, removeFile, setList],    return () => {

  );      cancelled = true;

    };

  // Reorder files function  }, [files, multiple, clearErrors, getList, removeFile, setList]);

  const reorderFiles = useCallback(

    (fromIndex: number, toIndex: number) => {  const handleRemove = useCallback(

      if (fromIndex === toIndex) return;    (id: string) => {

            const url = idToUrl.current[id];

      const currentUrls = getList();      if (url) {

      const reorderedUrls = [...currentUrls];        setList(getList().filter((u) => u !== url));

      const [movedItem] = reorderedUrls.splice(fromIndex, 1);        delete idToUrl.current[id];

      reorderedUrls.splice(toIndex, 0, movedItem);      }

            removeFile(id);

      setList(reorderedUrls);    },

    },    [getList, removeFile, setList],

    [getList, setList],  );

  );

  // Reorder files function

  // Drag and drop handlers for reordering  const reorderFiles = useCallback(

  const handleDragStart = useCallback((e: React.DragEvent, index: number) => {    (fromIndex: number, toIndex: number) => {

    setDraggedIndex(index);      if (fromIndex === toIndex) return;

    e.dataTransfer.effectAllowed = "move";      

    e.dataTransfer.setData("text/plain", index.toString());      const currentUrls = getList();

  }, []);      const reorderedUrls = [...currentUrls];

      const [movedItem] = reorderedUrls.splice(fromIndex, 1);

  const handleDragEnterReorder = useCallback((e: React.DragEvent, index: number) => {      reorderedUrls.splice(toIndex, 0, movedItem);

    e.preventDefault();      

    setDragOverIndex(index);      setList(reorderedUrls);

  }, []);    },

    [getList, setList],

  const handleDragOverReorder = useCallback((e: React.DragEvent) => {  );

    e.preventDefault();

    e.dataTransfer.dropEffect = "move";  // Drag and drop handlers for reordering

  }, []);  const handleDragStart = useCallback((e: React.DragEvent, index: number) => {

    setDraggedIndex(index);

  const handleDragLeaveReorder = useCallback(() => {    e.dataTransfer.effectAllowed = "move";

    setDragOverIndex(null);    e.dataTransfer.setData("text/plain", index.toString());

  }, []);  }, []);



  const handleDropReorder = useCallback(  const handleDragEnterReorder = useCallback((e: React.DragEvent, index: number) => {

    (e: React.DragEvent, dropIndex: number) => {    e.preventDefault();

      e.preventDefault();    setDragOverIndex(index);

      const dragIndex = draggedIndex;  }, []);

      

      if (dragIndex !== null && dragIndex !== dropIndex) {  const handleDragOverReorder = useCallback((e: React.DragEvent) => {

        reorderFiles(dragIndex, dropIndex);    e.preventDefault();

      }    e.dataTransfer.dropEffect = "move";

        }, []);

      setDraggedIndex(null);

      setDragOverIndex(null);  const handleDragLeaveReorder = useCallback(() => {

    },    setDragOverIndex(null);

    [draggedIndex, reorderFiles],  }, []);

  );

  const handleDropReorder = useCallback(

  const handleDragEndReorder = useCallback(() => {    (e: React.DragEvent, dropIndex: number) => {

    setDraggedIndex(null);      e.preventDefault();

    setDragOverIndex(null);      const dragIndex = draggedIndex;

  }, []);      

      if (dragIndex !== null && dragIndex !== dropIndex) {

  return (        reorderFiles(dragIndex, dropIndex);

    <FormField      }

      control={control}      

      name={name}      setDraggedIndex(null);

      render={() => (      setDragOverIndex(null);

        <FormItem className={className}>    },

          <FormLabel>{label}</FormLabel>    [draggedIndex, reorderFiles],

          <FormControl>  );

            <div className={cn("flex flex-col gap-2", viewClass)}>

              {/* biome-ignore lint: drag drop area is interactive */}  const handleDragEndReorder = useCallback(() => {

              <div    setDraggedIndex(null);

                onDragEnter={handleDragEnter}    setDragOverIndex(null);

                onDragLeave={handleDragLeave}  }, []);

                onDragOver={handleDragOver}

                onDrop={handleDrop}  return (

                data-dragging={isDragging || undefined}    <FormField

                data-files={files.length > 0 || undefined}      control={control}

                className={cn(      name={name}

                  "border-input data-[dragging=true]:bg-accent/50 has-[input:focus]:border-ring has-[input:focus]:ring-ring/50 relative flex min-h-52 flex-col items-center overflow-hidden rounded-xl border border-dashed p-4 transition-colors not-data-[files]:justify-center has-[input:focus]:ring-[3px]",      render={() => (

                )}        <FormItem className={className}>

              >          <FormLabel>{label}</FormLabel>

                <input          <FormControl>

                  {...getInputProps()}            <div className={cn("flex flex-col gap-2", viewClass)}>

                  className="sr-only"              {/* biome-ignore lint: drag drop area is interactive */}

                  aria-label="Upload image file"              <div

                />                onDragEnter={handleDragEnter}

                onDragLeave={handleDragLeave}

                {files.length > 0 ? (                onDragOver={handleDragOver}

                  <div className="flex w-full flex-col gap-3">                onDrop={handleDrop}

                    <div className="flex items-center justify-between gap-2">                data-dragging={isDragging || undefined}

                      <h3 className="truncate text-sm font-medium">                data-files={files.length > 0 || undefined}

                        Uploaded Files ({files.length})                className={cn(

                      </h3>                  "border-input data-[dragging=true]:bg-accent/50 has-[input:focus]:border-ring has-[input:focus]:ring-ring/50 relative flex min-h-52 flex-col items-center overflow-hidden rounded-xl border border-dashed p-4 transition-colors not-data-[files]:justify-center has-[input:focus]:ring-[3px]",

                      <Button                )}

                        variant="outline"              >

                        size="sm"                <input

                        onClick={openFileDialog}                  {...getInputProps()}

                        disabled={files.length >= maxFiles}                  className="sr-only"

                      >                  aria-label="Upload image file"

                        <UploadIcon                />

                          className="-ms-0.5 size-3.5 opacity-60"

                          aria-hidden="true"                {files.length > 0 ? (

                        />                  <div className="flex w-full flex-col gap-3">

                        {multiple ? "Add more" : "Replace"}                    <div className="flex items-center justify-between gap-2">

                      </Button>                      <h3 className="truncate text-sm font-medium">

                    </div>                        Uploaded Files ({files.length})

                      </h3>

                    <div className="grid grid-cols-2 gap-4 md:grid-cols-3 lg:grid-cols-4">                      <Button

                      {files.map((file, index) => {                        variant="outline"

                        const id = file.id as string;                        size="sm"

                        const isBusy = !!busyIds[id];                        onClick={openFileDialog}

                        const src = file.preview || "";                        disabled={files.length >= maxFiles}

                        const isDraggedOver = dragOverIndex === index;                      >

                        const isBeingDragged = draggedIndex === index;                        <UploadIcon

                          className="-ms-0.5 size-3.5 opacity-60"

                        return (                          aria-hidden="true"

                          <div                        />

                            key={id}                        {multiple ? "Add more" : "Replace"}

                            className={cn(                      </Button>

                              "bg-accent relative aspect-square rounded-md transition-all duration-200",                    </div>

                              isDraggedOver && "ring-2 ring-primary scale-105",

                              isBeingDragged && "opacity-50 scale-95",                    <div className="grid grid-cols-2 gap-4 md:grid-cols-3 lg:grid-cols-4">

                            )}                      {files.map((file, index) => {

                          >                        const id = file.id as string;

                            {/* Drag handle overlay - only show for multiple files */}                        const isBusy = !!busyIds[id];

                            {multiple && !isBusy && (                        const src = file.preview || "";

                              <button                        const isDraggedOver = dragOverIndex === index;

                                type="button"                        const isBeingDragged = draggedIndex === index;

                                draggable

                                onDragStart={(e) => handleDragStart(e, index)}                        return (

                                onDragEnter={(e) => handleDragEnterReorder(e, index)}                          <div

                                onDragOver={handleDragOverReorder}                            key={id}

                                onDragLeave={handleDragLeaveReorder}                            className={cn(

                                onDrop={(e) => handleDropReorder(e, index)}                              "bg-accent relative aspect-square rounded-md transition-all duration-200",

                                onDragEnd={handleDragEndReorder}                              isDraggedOver && "ring-2 ring-primary scale-105",

                                className="absolute inset-0 z-10 cursor-move bg-transparent"                              isBeingDragged && "opacity-50 scale-95",

                                aria-label={`Drag to reorder image ${index + 1}`}                            )}

                              />                          >

                            )}                            {/* Drag handle overlay */}

                                                        {multiple && !isBusy && (

                            {/* Drag grip indicator */}                              <div

                            {multiple && !isBusy && (                                draggable

                              <div className="absolute top-1 left-1 z-20 p-1 rounded-full bg-black/20 backdrop-blur-sm pointer-events-none">                                onDragStart={(e) => handleDragStart(e, index)}

                                <GripVerticalIcon className="size-3 text-white" />                                onDragEnter={(e) => handleDragEnterReorder(e, index)}

                              </div>                                onDragOver={handleDragOverReorder}

                            )}                                onDragLeave={handleDragLeaveReorder}

                                                            onDrop={(e) => handleDropReorder(e, index)}

                            {src ? (                                onDragEnd={handleDragEndReorder}

                              <Image                                className="absolute inset-0 z-10 cursor-move"

                                src={src}                                role="button"

                                alt={file.file?.name ?? "image"}                                tabIndex={0}

                                fill                                aria-label={`Drag to reorder image ${index + 1}`}

                                className="rounded-[inherit] object-cover"                                onKeyDown={(e) => {

                              />                                  if (e.key === 'Enter' || e.key === ' ') {

                            ) : (                                    e.preventDefault();

                              <div className="text-muted-foreground flex h-full w-full items-center justify-center text-xs">                                    // Could implement keyboard navigation here

                                Preview not available                                  }

                              </div>                                }}

                            )}                              />

                            )}

                            <Button                            {multiple && !isBusy && (

                              onClick={() => handleRemove(id)}                              <div className="absolute top-1 left-1 z-10 p-1 rounded-full bg-black/20 backdrop-blur-sm">

                              size="icon"                                <GripVerticalIcon className="size-3 text-white" />

                              className="border-background focus-visible:border-background absolute -top-2 -right-2 size-6 rounded-full border-2 shadow-none z-30"                              </div>

                              aria-label="Remove image"                            )}

                              disabled={isBusy}                            

                            >                            {src ? (

                              <XIcon className="size-3.5" />                              <Image

                            </Button>                                src={src}

                                alt={file.file?.name ?? "image"}

                            {isBusy && (                                fill

                              <div className="absolute inset-0 grid place-items-center rounded-[inherit] bg-black/30 text-[11px] text-white z-20">                                className="rounded-[inherit] object-cover"

                                Uploading…                              />

                              </div>                            ) : (

                            )}                              <div className="text-muted-foreground flex h-full w-full items-center justify-center text-xs">

                          </div>                                Preview not available

                        );                              </div>

                      })}                            )}

                    </div>

                  </div>                            <Button

                ) : (                              onClick={() => handleRemove(id)}

                  <div className="flex flex-col items-center justify-center px-4 py-3 text-center">                              size="icon"

                    <div                              className="border-background focus-visible:border-background absolute -top-2 -right-2 size-6 rounded-full border-2 shadow-none"

                      className="bg-background mb-2 flex size-11 shrink-0 items-center justify-center rounded-full border"                              aria-label="Remove image"

                      aria-hidden="true"                              disabled={isBusy}

                    >                            >

                      <ImageIcon className="size-4 opacity-60" />                              <XIcon className="size-3.5" />

                    </div>                            </Button>

                    <p className="mb-1.5 text-sm font-medium">

                      Drop your images here                            {isBusy && (

                    </p>                              <div className="absolute inset-0 grid place-items-center rounded-[inherit] bg-black/30 text-[11px] text-white">

                    <p className="text-muted-foreground text-xs">                                Uploading…

                      SVG, PNG, JPG or GIF (max. {maxSizeMB}MB)                              </div>

                    </p>                            )}

                    <Button                          </div>

                      variant="outline"                        );

                      className="mt-4"                      })}

                      onClick={openFileDialog}                    </div>

                    >                  </div>

                      <UploadIcon                ) : (

                        className="-ms-1 opacity-60"                  <div className="flex flex-col items-center justify-center px-4 py-3 text-center">

                        aria-hidden="true"                    <div

                      />                      className="bg-background mb-2 flex size-11 shrink-0 items-center justify-center rounded-full border"

                      {multiple ? "Select images" : "Select image"}                      aria-hidden="true"

                    </Button>                    >

                  </div>                      <ImageIcon className="size-4 opacity-60" />

                )}                    </div>

              </div>                    <p className="mb-1.5 text-sm font-medium">

                      Drop your images here

              {(errors.length > 0 || topError) && (                    </p>

                <div                    <p className="text-muted-foreground text-xs">

                  className="text-destructive flex items-center gap-1 text-xs"                      SVG, PNG, JPG or GIF (max. {maxSizeMB}MB)

                  role="alert"                    </p>

                >                    <Button

                  <AlertCircleIcon className="size-3 shrink-0" />                      variant="outline"

                  <span>{topError ?? errors[0]}</span>                      className="mt-4"

                </div>                      onClick={openFileDialog}

              )}                    >

            </div>                      <UploadIcon

          </FormControl>                        className="-ms-1 opacity-60"

          <FormMessage />                        aria-hidden="true"

        </FormItem>                      />

      )}                      {multiple ? "Select images" : "Select image"}

    />                    </Button>

  );                  </div>

}                )}
              </div>

              {(errors.length > 0 || topError) && (
                <div
                  className="text-destructive flex items-center gap-1 text-xs"
                  role="alert"
                >
                  <AlertCircleIcon className="size-3 shrink-0" />
                  <span>{topError ?? errors[0]}</span>
                </div>
              )}
            </div>
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
