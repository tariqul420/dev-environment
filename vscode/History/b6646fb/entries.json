{"version":1,"resource":"file:///home/tariqul/Projects/natural-sefa-v2/lib/actions/user.action.ts","entries":[{"id":"wwh6.ts","timestamp":1758559405551},{"id":"BsQv.ts","timestamp":1758559439882},{"id":"DpW5.ts","timestamp":1758559490702},{"id":"TKDF.ts","timestamp":1758559503320},{"id":"MMEG.ts","timestamp":1758559539607},{"id":"cVcz.ts","timestamp":1758559578553},{"id":"HJLw.ts","source":"Apply all safe fixes (Biome)","timestamp":1758559605870},{"id":"YjAw.ts","timestamp":1758559610455},{"id":"85Ot.ts","timestamp":1758559632630},{"id":"xoGN.ts","timestamp":1758559672789},{"id":"XzLb.ts","source":"Apply all safe fixes (Biome)","timestamp":1758559679639},{"id":"DYlX.ts","timestamp":1758559695179},{"id":"JnqQ.ts","source":"Apply all safe fixes (Biome)","timestamp":1758560156633},{"id":"7Zxe.ts","timestamp":1758560171721},{"id":"syYA.ts","timestamp":1758560218512},{"id":"Ktmi.ts","timestamp":1758560362864},{"id":"LwH6.ts","timestamp":1758560786286},{"id":"sYIP.ts","timestamp":1758560847281},{"id":"1jpK.ts","timestamp":1758560959388},{"id":"7Clb.ts","source":"Apply all safe fixes (Biome)","timestamp":1758560987350},{"id":"XiN1.ts","timestamp":1758561021727},{"id":"NvYP.ts","timestamp":1758561125525},{"id":"Ho8e.ts","source":"Apply all safe fixes (Biome)","timestamp":1758561158014},{"id":"SO7o.ts","timestamp":1758561176442},{"id":"I4aI.ts","source":"Apply all safe fixes (Biome)","timestamp":1758561185308},{"id":"9Adt.ts","timestamp":1758561189702},{"id":"cFoU.ts","timestamp":1758561377488},{"id":"UhBl.ts","timestamp":1758561422994},{"id":"F0sc.ts","timestamp":1758561485156},{"id":"OfIB.ts","timestamp":1758561676459},{"id":"IZcY.ts","timestamp":1758593150447},{"id":"KPUI.ts","timestamp":1758594163944},{"id":"taeu.ts","timestamp":1758594174242},{"id":"jAHD.ts","timestamp":1758594191120},{"id":"hzpX.ts","timestamp":1758594299845},{"id":"rWRK.ts","timestamp":1758595276296},{"id":"uPTp.ts","timestamp":1758595300535},{"id":"N8LM.ts","timestamp":1758595348060},{"id":"bJTv.ts","timestamp":1758595371621},{"id":"AOTy.ts","timestamp":1758596243991},{"id":"bGae.ts","timestamp":1758939300516},{"id":"NhRF.ts","source":"Chat Edit: 'export async function getUsersForAdmin({\n  page = 1,\n  limit = 25,\n  search = \"\",\n}: GetUsersInput) {\n  try {\n    await requireAdmin();\n\n    const currentPage = Math.max(1, Math.floor(page));\n    const perPage = Math.min(100, Math.max(1, Math.floor(limit)));\n    const skip = (currentPage - 1) * perPage;\n\n    const where: Prisma.UserWhereInput = {\n      ...(search && {\n        OR: [\n          { name: { contains: search, mode: \"insensitive\" } },\n          { email: { contains: search, mode: \"insensitive\" } },\n          { phone: { contains: search, mode: \"insensitive\" } },\n        ],\n      }),\n    };\n\n    const [users, totalItems] = await prisma.$transaction([\n      prisma.user.findMany({\n        where,\n        skip,\n        take: perPage,\n        orderBy: { createdAt: \"desc\" },\n        select: {\n          id: true,\n          name: true,\n          email: true,\n          imageUrl: true,\n          role: true,\n          createdAt: true,\n          updatedAt: true,\n        },\n      }),\n      prisma.user.count({ where }),\n    ]);\n\n    if (users.length === 0) {\n      const totalPages = Math.max(1, Math.ceil(totalItems / perPage));\n      return {\n        users: [],\n        pagination: {\n          currentPage,\n          totalPages,\n          totalItems,\n          hasNextPage: currentPage < totalPages,\n          hasPrevPage: currentPage > 1,\n        },\n      };\n    }\n\n    const userIds = users.map((u) => u.id);\n\n    const ordersAgg = (await prisma.order.groupBy({\n      by: [\"userId\"],\n      where: { userId: { in: userIds } },\n      _count: { _all: true },\n      _sum: { total: true },\n      _max: { createdAt: true },\n    })) as Array<{\n      userId: string;\n      _count: { _all: number };\n      _sum: { total: Prisma.Decimal | null };\n      _max: { createdAt: Date | null };\n    }>;\n\n    const completedAgg = (await prisma.order.groupBy({\n      by: [\"userId\"],\n      where: {\n        userId: { in: userIds },\n        status: { in: [OrderStatus.DELIVERED, OrderStatus.CONFIRMED] },\n      },\n      _count: { _all: true },\n    })) as Array<{\n      userId: string;\n      _count: { _all: number };\n    }>;\n\n    const ordersMap = new Map(\n      ordersAgg.map((r) => [\n        r.userId as string,\n        {\n          totalOrders: r._count._all,\n          totalSpent: r._sum.total,\n          lastOrderAt: r._max.createdAt,\n        },\n      ]),\n    );\n    const completedMap = new Map(\n      completedAgg.map((r) => [r.userId as string, r._count._all]),\n    );\n\n    // Merge\n    const rows: AdminUserRow[] = users.map((u) => {\n      const o = ordersMap.get(u.id);\n      const completed = completedMap.get(u.id) ?? 0;\n\n      return {\n        ...u,\n        totalOrders: o?.totalOrders ?? 0,\n        completedOrders: completed,\n        totalSpent: (\n          o?.totalSpent ?? (0 as unknown as Prisma.Decimal)\n        ).toString(),\n        lastOrderAt: o?.lastOrderAt ?? null,\n      };\n    });\n\n    const totalPages = Math.max(1, Math.ceil(totalItems / perPage));\n\n    return {\n      users: JSON.parse(JSON.stringify(rows)),\n      pagination: {\n        currentPage,\n        totalPages,\n        totalItems,\n        hasNextPage: currentPage < totalPages,\n        hasPrevPage: currentPage > 1,\n      },\n    };\n  } catch (error) {\n    logger.error(\n      \"Error fetching users for admin: \" +\n        (error instanceof Error ? error.message : String(error)),\n    );\n    throw new Error(\"Failed to fetch users\", { cause: error });\n  }\n}\n\n\nIF ORDER STATUS JODI CONFIRMED OR DELIVERD HOI TAHOLE IF ORDER STATUS JODI CONFIRMED OR DELIVERD HOI TAHOLE TOTAL totalSpent A COUNT HOBE'","timestamp":1758939688143}]}